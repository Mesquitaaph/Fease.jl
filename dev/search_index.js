var documenterSearchIndex = {"docs":
[{"location":"para-comecar/para-começar-a-utilizar/#Para-começar-a-utilizar","page":"A Utilizar","title":"Para começar a utilizar","text":"","category":"section"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Neste capítulo esclareceremos os passos necessários para começar a utilizar o pacote.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/#Instalando-o-pacote","page":"A Utilizar","title":"Instalando o pacote","text":"","category":"section"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"O pacote pode ser instalado em seu ambiente de duas formas distintas: através dos gerenciador de pacotes de Julia ou através do projeto clonado. As apresentaremos a seguir.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/#Através-do-gerenciador-de-pacotes-de-Julia","page":"A Utilizar","title":"Através do gerenciador de pacotes de Julia","text":"","category":"section"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Ainda não subimos no gerenciador de pacotes.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/#Através-do-projeto-clonado","page":"A Utilizar","title":"Através do projeto clonado","text":"","category":"section"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Ao iniciar o REPL da Julia, você verá escrito julia>. Para utilizar o Fease.jl é preciso adicioná-lo ao seu ambiente. Para isso, digite ] na linha de comando para entrar no modo package. Deverá aparecer algo como (nome_do_ambiente) pkg> no lugar. Em seguida, adicione-o como um pacote de desenvolvimento digitando","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"(nome_do_ambiente) pkg> dev C:\\caminho\\para\\o\\Fease\n  Resolving package versions...","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Para verificar se o pacote está funcionando corretamente execute o comando test como apresentado abaixo.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"(nome_do_ambiente) pkg> test Fease\n  Testing Fease\n  Status ...","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Ao final deverá aparecer algo como","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"    Testing Running tests...\nTest Summary: | Pass  Total  Time\ncaso1D.jl     |    2      2  0.6s\nTest Summary: | Pass  Total  Time\ncaso2D.jl     |    2      2  0.1s\n    Testing Fease tests passed","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/#Utilizando-o-pacote","page":"A Utilizar","title":"Utilizando o pacote","text":"","category":"section"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"A partir disso, é possível utilizar o Fease incluindo o trecho abaixo no topo de seu código","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"using Fease","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"O fluxo de implementação inicia definindo o conjunto de funções base. Primeiro declaramos a quantidade de elementos finitos. Em seguida, o tipo das funções base.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Nx1 = 2^3\n\nbaseType = BaseTypes.linearLagrange","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Com a base definida, construímos a malha utilizando algumas funções já implementadas, como monta_malha_1D_uniforme. Para esta, precisamos declarar os pontos inicial e final do intervalo a b.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"# Define extremos do intervalo da malha.\na, b = 0, 1\n\n# Define a malha com os valores atribuídos acima.\nmalha = monta_malha_1D_uniforme(baseType, Nx1, a, b)","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"O próximo passo é definir os valores do problema. Para este tutorial, podemos utilizar valores de problemas exemplo do Caso 1D","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"# Define os parâmetros da equação a ser resolvida.\nexample = 1\nrun_values = examples_1D(example)\n(; α, β, f) = run_values","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Em seguida, montamos uma função que referencia o operador bilinear a(uv) com parâmetros obtidos de run_values.","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"# Define o pseudo operador linear a(u,v).\nfunction pseudo_a(termos_equacao)\n  (; ∇u, ∇v, u, v) = termos_equacao\n\n  return β * dot(u, v) + α * dot(∇u, ∇v)\nend","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Enfim, com a f e a malha definidas e o operador a(u v) referenciado, basta resolver o sistema, digitando","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"# Monta e resolve o sistema linear relacionado a esta equação.\nc = solve_sys(f, malha, pseudo_a)","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Obtendo o resultado","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"7-element Vector{Float64}:\n 0.11108398583873315\n 0.21339432867780742\n 0.29760326069653276\n 0.3532397670750393\n 0.36802825874249573\n 0.32711327201474155\n 0.2121212287826553","category":"page"},{"location":"para-comecar/para-começar-a-utilizar/","page":"A Utilizar","title":"A Utilizar","text":"Para mais informações de uso, vá para Tutoriais","category":"page"},{"location":"desenvolvimento-colaborativo/ferramentas/#Ferramentas-Sugeridas-ou-Necessárias","page":"Ferramentas","title":"Ferramentas Sugeridas ou Necessárias","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/ferramentas/","page":"Ferramentas","title":"Ferramentas","text":"Aqui apresentaremos as ferramentas sugeridas ou necessárias para o desenvolvimento colaborativo deste projeto.","category":"page"},{"location":"desenvolvimento-colaborativo/ferramentas/#VS-Code","page":"Ferramentas","title":"VS Code","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/ferramentas/","page":"Ferramentas","title":"Ferramentas","text":"O Visual Studio Code é o editor de código-fonte utilizado durante o desenvolvimento deste projeto. Algumas automatizações, como a auto formatação do código ao salvar foi implementada para o VSCode. Sua utilização não é obrigatória, mas recomendada. Atualmente não temos planos de considerar outros editores de código-fonte.","category":"page"},{"location":"tutoriais/novo-termo/#Novo-termo-de-Equação","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"","category":"section"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Esta página é uma extensão do final da explicação da Implementação Base. Se você quer uma explicação do que está sendo feito aqui, recomendamos que leia esta outra página.","category":"page"},{"location":"tutoriais/novo-termo/#Preparando-a-implementação","page":"Novo termo de Equação","title":"Preparando a implementação","text":"","category":"section"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Com o código-fonte em mãos, na pasta src/testes, crie um arquivo para testarmos o que implementaremos, por exemplo, testes_novo_termo.jl. Além disso, no final do arquivo include_testes.jl, na mesma pasta, inclua o recém criado.","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"include(\"testes_novo_termo.jl\")","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Em seguida, no arquivo criado, vamos implementar uma função chamada novo_termo_2D, para adicionar um novo termo de equação e testá-lo, em um espaço bidimensional. Essa função criada vai ter como base o exemplo em example/Caso2D.jl.","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"function novo_termo()\n  # Define o número de sub-intervalos no eixo horizontal e vertical, respectivamente.\n  Nx1, Nx2 = 8, 8\n\n  # Define o tipo da base de funções interpoladoras do subespaço aproximado Vₘ.\n  baseType = BaseTypes.linearLagrange\n\n  # Define extremos do intervalo da malha.\n  a = (0.0, 0.0)\n  b = (1.0, 1.0)\n\n  # Define a malha com os valores atribuídos acima.\n  malha = monta_malha_2D_uniforme(baseType, Nx1, Nx2, a, b)\n\n  # Define os parâmetros da equação a ser resolvida.\n  α = 1.0\n  β = 1.0\n  f = (x₁, x₂) -> (2 * α * π^2 + β) * sin(π * x₁) * sin(π * x₂)\n\n  # Define o pseudo operador linear a(u,v).\n  function pseudo_a(termos_equacao)\n    (; ∇u, ∇v, u, v) = termos_equacao\n\n    return β * dot(u, v) + α * dot(∇u, ∇v)\n  end\n\n  # Monta e resolve o sistema linear relacionado a esta equação.\n  c = solve_sys(f, malha, pseudo_a)\n\n  # Imprime solução aproximada.\n  show(c)\n\n  # Plota solução aproximada.\n  return plot_solucao_aproximada(c, malha, false)\nend","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Verifique se está tudo funcionando rodando a função novo_termo_2D(). Se aparecer o gráfico plotado, como abaixo, podemos seguir com o tutorial. (Image: Solução Caso 2D)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"O gráfico, portanto, apresenta a solução aproximada do problema definido em Equação similar à Poisson no espaço bidimensional, ou seja:","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Dada uma função f barOmega to mathbbR e constantes reais alpha  0 e beta geq 0, determine u barOmega to mathbbR tal que","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"left\nbeginaligned\n-alphaDelta u(x) + beta u(x) = f(x)quad xin Omega\nu(x) = 0 quad x in Gamma\nendaligned\nright","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"sendo Omega um subconjunto do mathbbR^2, Gamma a fronteira de Omega e barOmega = Omega cup Gamma.","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"A seguir apresentaremos como adaptar o código para conseguirmos resolver a seguinte variação da equação acima","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"-alpha(x)Delta u(x) + beta u(x) = f(x)quad xin Omega","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Em breve, adicionaremos o seu desenvolvimento na formulação fraca, necessária para montar a pseudo_a do problema.","category":"page"},{"location":"tutoriais/novo-termo/#Implementando-o-novo-termo","page":"Novo termo de Equação","title":"Implementando o novo termo","text":"","category":"section"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Vá no arquivo src/examples.jl. No final do arquivo, vamos adicionar, à estrutura TermosEquacao, um termo novo para que possamos adicinar uma parcela dependente de x na equacao. Vamos chamar este novo termo de, simplesmente, x. A estrutura sairá de","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"struct TermosEquacao\n  u\n  v\n  ∇u\n  ∇v\nend","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"para","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"struct TermosEquacao\n  u\n  v\n  ∇u\n  ∇v\n  x\nend","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Para que esse novo termo possa ser considerado nos cáculos do problema, ele deve ser referenciado na funcão montaKᵉ_geral!, especificamente no loop mais interno. A mudança é análoga à realizada em TermosEquacao, saindo de","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"termos_equacao = TermosEquacao(\n  ϕᵉ_b,\n  ϕᵉ_a,\n  ∇ϕᵉ_b,\n  ∇ϕᵉ_a\n)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"para","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"termos_equacao = TermosEquacao(\n  ϕᵉ_b,\n  ϕᵉ_a,\n  ∇ϕᵉ_b,\n  ∇ϕᵉ_a,\n  x\n)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Agora basta utilizá-lo. De volta no arquivo inicial testes_novo_termo.jl, vamos alterar a definição de α e, portanto, remova sua definição original trocando","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"α = 1.0","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Pela função exemplo","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"α(x₁, x₂) = x₁ + x₂","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Além disso, vamos precisar definir uma outra função","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"∇α(x₁, x₂) = [1 1]","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Agora precisamos alterar como a pseudo_a funciona. Começamos acrescentando o termo x que criamos na extração dos termos da equação, alterando o trecho","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"(; ∇u, ∇v, u, v) = termos_equacao","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"para","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"(; ∇u, ∇v, u, v, x) = termos_equacao","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Por fim, mudamos a utilização da variável para tornar-se uma chamada de função, ou seja, de","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"return β * dot(u, v) + α * dot(∇u, ∇v)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"para","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"return β * dot(u, v) + α(x...) * dot(∇u, ∇v) + dot(dot(∇α(x...), ∇u), v)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Note que ambas α e ∇α recebem o ponto x com um splatting, ou seja, no conjunto x.... Além disso, a parcela extra dot(dot(∇α(x...), ∇u), v) é uma consequência de tornar alpha uma função na equação.","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Note que ambas α e ∇α recebem o ponto x com um splatting, ou seja, no conjunto x..., pois é o padrão que utilizamos para uma função receber mais de uma variável a partir de uma tupla. Assim, a definimos esperando duas variáveis de forma que o código base não precise saber essa quantidade de variáveis.","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Ao final de todas essas alterações, a função novo_termo_2D ficará assim:","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"function novo_termo()\n  # Define o número de sub-intervalos no eixo horizontal e vertical, respectivamente.\n  Nx1, Nx2 = 8, 8\n\n  # Define o tipo da base de funções interpoladoras do subespaço aproximado Vₘ.\n  baseType = BaseTypes.linearLagrange\n\n  # Define extremos do intervalo da malha.\n  a = (0.0, 0.0)\n  b = (1.0, 1.0)\n\n  # Define a malha com os valores atribuídos acima.\n  malha = monta_malha_2D_uniforme(baseType, Nx1, Nx2, a, b)\n\n  # Define os parâmetros da equação a ser resolvida.\n  α = 1.0\n  β = 1.0\n  f = (x₁, x₂) -> (2 * α * π^2 + β) * sin(π * x₁) * sin(π * x₂)\n\n  # Define o pseudo operador linear a(u,v).\n  function pseudo_a(termos_equacao)\n    (; ∇u, ∇v, u, v) = termos_equacao\n\n    return β * dot(u, v) + α(x...) * dot(∇u, ∇v) + dot(dot(∇α(x...), ∇u), v)\n  end\n\n  # Monta e resolve o sistema linear relacionado a esta equação.\n  c = solve_sys(f, malha, pseudo_a)\n\n  # Imprime solução aproximada.\n  show(c)\n\n  # Plota solução aproximada.\n  return plot_solucao_aproximada(c, malha, false)\nend","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Verifique novamente se está tudo funcionando rodando a nova função novo_termo_2D(). Se aparecer o gráfico plotado, igual ao de antes das mudanças, as alterações foram realizadas com sucesso! (Image: Solução Caso 2D)","category":"page"},{"location":"tutoriais/novo-termo/","page":"Novo termo de Equação","title":"Novo termo de Equação","text":"Você também pode aplicar o tutorial de Estudo de Convergência do Erro e verificar se a convergência do erro segue o esperado. Caso contrário, revise seu código e encontre o erro.","category":"page"},{"location":"tutoriais/poisson-2d/#Equação-similar-à-Poisson-no-espaço-bidimensional","page":"Equação de Poisson 2D","title":"Equação similar à Poisson no espaço bidimensional","text":"","category":"section"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Para este tutorial é esperado que você tenha seguido o passo a passo em Para começar a utilizar. As próximas etapas serão parecidas com as apresentadas no artigo.","category":"page"},{"location":"tutoriais/poisson-2d/#A-equação","page":"Equação de Poisson 2D","title":"A equação","text":"","category":"section"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Como apresentado no título, a equação a ser resolvida é similar à de Poisson, com uma parcela extra. Portanto, vamos ao problema:","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Dada uma função f barOmega to mathbbR e constantes reais alpha  0 e beta geq 0, determine u barOmega to mathbbR tal que","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"left\nbeginaligned\n-alphaDelta u(x) + beta u(x) = f(x)quad xin Omega\nu(x) = 0 quad x in Gamma\nendaligned\nright","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"sendo Omega um subconjunto do mathbbR^2, Gamma a fronteira de Omega e barOmega = Omega cup Gamma.","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Assim, o que queremos é encontrar uma solução aproximada de u com o Fease.jl. A seguir temos o passo a passo para obtê-la.","category":"page"},{"location":"tutoriais/poisson-2d/#Passo-a-passo","page":"Equação de Poisson 2D","title":"Passo a passo","text":"","category":"section"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Comece importando o pacote","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"using Fease","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Defina o tipo do conjunto de funções da base e a quantidade de intervalos em ambas as dimensões, assim como o número de elementos, considerando uma malha retangular uniforme.","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"baseType = BaseTypes.linearLagrange\n\nNx1, Nx2 = 4, 4","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Em seguida, defina os pontos de intervalo da malha e chame uma função para construção da malha. Nesse exemplo, utilizaremos monta_malha_2D_uniforme.","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"a = (0.0, 0.0) # Inicio do intervalo\nb = (1.0, 1.0) # Fim do intervalo\n\nmalha = monta_malha_2D_uniforme(baseType, Nx1, Nx2, a, b)","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Agora, definimos alguns parâmetros do problema","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"α = 1.0\nβ = 1.0\nf = (x₁, x₂) -> (2 * α * π^2 + β) * sin(π * x₁) * sin(π * x₂)\nu = (x₁, x₂) -> sin(π * x₁) * sin(π * x₂)","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Em seguida, montamos uma função que referencia o operador bilinear a(uv) com parâmetros obtidos de run_values.","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"function pseudo_a(termos_equacao::TermosEquacao)\n  (; ∇u, ∇v, u, v) = termos_equacao\n\n  return β * dot(u, v) + α * dot(∇u, ∇v)\nend","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Enfim, com a f e a malha definidas e o operador a(u v) referenciado, basta resolver o sistema, com","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"c = solve_sys(f, malha, pseudo_a)","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Resultando em","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"9-element Vector{Float64}:\n 0.527459460647701\n 0.7459403228499766\n 0.5274594606477011\n ⋮\n 0.7459403228499767\n 0.5274594606477011","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Com esse resultado também é possível utilizar um método implementado internamente para plotar esse resultado,","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"plot_solucao_aproximada(C, malha, false)","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Resultando no gráfico","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"(Image: Solução Poisson 2D)","category":"page"},{"location":"tutoriais/poisson-2d/","page":"Equação de Poisson 2D","title":"Equação de Poisson 2D","text":"Você também pode aplicar o tutorial de Estudo de Convergência do Erro e verificar se a convergência do erro segue o esperado. Caso contrário, revise seu código e encontre o erro.","category":"page"},{"location":"tutoriais/outras-malhas/#Outras-malhas-disponíveis","page":"Outras Malhas","title":"Outras malhas disponíveis","text":"","category":"section"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Aqui apresentaremos algumas opções de malha para utilizar diferentes da uniforme apresentada em Equação de Poisson 2D.","category":"page"},{"location":"tutoriais/outras-malhas/#Malha-com-ruído","page":"Outras Malhas","title":"Malha com ruído","text":"","category":"section"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Essa é uma malha derivada da uniforme na qual seus nós internos se distanciam da posição original com um valor aleatório dentro de um intervalo específico. Este valor é o que chamamos de ruído, neste caso.","category":"page"},{"location":"tutoriais/outras-malhas/#Passo-a-passo","page":"Outras Malhas","title":"Passo a passo","text":"","category":"section"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Primeiro, construa a malha uniforme","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Nx1, Nx2 = 4, 4\n\nbaseType = BaseTypes.linearLagrange\n\na = (0.0, 0.0)\nb = (1.0, 1.0)\n\nmalha = monta_malha_2D_uniforme(baseType, Nx1, Nx2, a, b)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Vamos plotar essa nova malha construída utilizando uma das funções internas de plot","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"plot_malha_2D(malha)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"(Image: Malha Uniforme Bidimensional)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Agora, para aplicar o ruído é simples, basta fazer","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"malha = malha2D_adiciona_ruido(malha)\n\nplot_malha_2D(malha)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Resultando na malha","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"(Image: Malha Uniforme com ruído Bidimensional) Apenas destacamos que o ruído aleatório varia, naturalmente, entre execuções distintas do programa.","category":"page"},{"location":"tutoriais/outras-malhas/#Malha-com-concentração-de-elementos-em-ponto-focal","page":"Outras Malhas","title":"Malha com concentração de elementos em ponto focal","text":"","category":"section"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Essa próxima malha também deriva da uniforme, porém de forma distinta. Neste caso chamamos outra função montadora. Sua chamada é muito parecida com a primeira, com um dois parâmetros a mais: ponto_foco e precisao.","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Nx1, Nx2 = 4, 4\n\nbaseType = BaseTypes.linearLagrange\n\na = (0.0, 0.0)\nb = (1.0, 1.0)\n\nponto_foco = (0.375, 0.375)\nprecisao = 0\n\nmalha = monta_malha_2D_foco(baseType, Nx1, Nx2, a, b, ponto_foco, precisao)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"O ponto_foco é um ponto na malha que vai se tornar, se já não for, um ponto com quatro elementos adjacentes. Na figura abaixo, temos a malha com o ponto de foco em (0375 0375), ponto este que não existia na malha uniforme, de onde derivamos.","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"plot_malha_2D(malha)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"(Image: Malha Uniforme Bidimensional com Foco)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"A precisao é a quantidade de iterações de incremento de intervalos em torno do ponto_foco. Com precisao = 1 os intervalos mais próximos à esquerda e à direita do ponto focal serão divididos em dois, assim como os intervalos mais proximos acima e abaixo.","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"ponto_foco = (0.375, 0.375)\nprecisao = 1\n\nmalha = monta_malha_2D_foco(baseType, Nx1, Nx2, a, b, ponto_foco, precisao)\n\nplot_malha_2D(malha)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"(Image: Malha Uniforme Bidimensional com Foco e Precisão 1)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"Assim notamos que o número de elementos próximos ao ponto focal é maior que originalmente. Isso permite uma precisão maior em determinadas regiões.","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"ponto_foco = (0.375, 0.375)\nprecisao = 2\n\nmalha = monta_malha_2D_foco(baseType, Nx1, Nx2, a, b, ponto_foco, precisao)\n\nplot_malha_2D(malha)","category":"page"},{"location":"tutoriais/outras-malhas/","page":"Outras Malhas","title":"Outras Malhas","text":"(Image: Malha Uniforme Bidimensional com Foco e Precisão 2)","category":"page"},{"location":"contatos/#Contatos","page":"Contatos","title":"Contatos","text":"","category":"section"},{"location":"contatos/","page":"Contatos","title":"Contatos","text":"Aqui colocaremos informações de contatos. Exemplos:","category":"page"},{"location":"contatos/","page":"Contatos","title":"Contatos","text":"Telegram e/ou E-mails dos colaboradores ativos e voluntários.\nUm grupo no Telegram?\nE-mail do LC³","category":"page"},{"location":"tutoriais/#Tutoriais","page":"Introdução","title":"Tutoriais","text":"","category":"section"},{"location":"tutoriais/","page":"Introdução","title":"Introdução","text":"Nesta seção, apresentaremos algumas das possibilidades que o Fease.jl provê para o usuário, que vai desde formas de preparar e resolver um problema de EDP até como contribuir para o projeto.","category":"page"},{"location":"tutoriais/#Tutoriais-de-Uso","page":"Introdução","title":"Tutoriais de Uso","text":"","category":"section"},{"location":"tutoriais/","page":"Introdução","title":"Introdução","text":"Poisson 2D\nOutros tipos de malha\nEstudo de convergência do erro","category":"page"},{"location":"tutoriais/#Tutoriais-de-Desenvolvimento","page":"Introdução","title":"Tutoriais de Desenvolvimento","text":"","category":"section"},{"location":"tutoriais/","page":"Introdução","title":"Introdução","text":"Adicionando novo termo","category":"page"},{"location":"tutoriais/convergencia/#Estudo-da-Convergência-do-Erro-Poisson","page":"Estudo de Convergência do Erro","title":"Estudo da Convergência do Erro - Poisson","text":"","category":"section"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Aqui apresentaremos um exemplo de estudo da convergência do erro, no caso da equação de Poisson.","category":"page"},{"location":"tutoriais/convergencia/#Passo-a-passo","page":"Estudo de Convergência do Erro","title":"Passo a passo","text":"","category":"section"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Começamos de forma análoga a Equação de Poisson 2D","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"using Fease\n\nbaseType = BaseTypes.linearLagrange\n\na = (0.0, 0.0)\nb = (1.0, 1.0)","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Agora, para a montagem da malha, implementamos uma contrutora de malha que dependa apenas da quantidade de intervalos nos eixos, no caso NX.","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"# Função que recebe uma tupla ou lista e retorna a malha montada com valores de baseType, a, b predefinidos\nfunction monta_malha(NX)\n  return monta_malha_2D_uniforme(baseType, NX..., a, b)\nend","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Em monta_malha_2D_uniforme, NX é seguido de reticências pois a função espera dois parâmetros antes de baseType e a, b. Portanto, esse ... destaca cada elemento de NX individualmente.","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Em seguida, defina os parâmetros do problema","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"α = 1.0\nβ = 1.0\nf = (x₁, x₂) -> (2 * α * π^2 + β) * sin(π * x₁) * sin(π * x₂)\nu = (x₁, x₂) -> sin(π * x₁) * sin(π * x₂)\n\n# Define o pseudo operador linear a(u,v).\nfunction pseudo_a(termos_equacao)\n  (; ∇u, ∇v, u, v) = termos_equacao\n\n  return β * dot(u, v) + α * dot(∇u, ∇v)\nend\n\nn_dims = 2","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Para o estudo da convergência do erro, realizaremos uma sequência de sistemas com malhas cujos números de elementos sejam potências de dois, crescentes. Nesse exemplo, trabalharemos com 2^2 até 2^7","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"errsize = 7\nNE = 2 .^ [2:1:errsize;]\n\nH = 1 ./ NE # Considerando malhas com intervalos uniformes, a lista de intervalos para cada uma das quantidade de elementos em NE\nE = zeros(length(NE)) # Vetor com os erros para cada uma das quantidades de elementos","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"A partir disso, podemos calcular a convergência do erro com","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"convergence_test!(E, NE, n_dim, monta_malha, pseudo_a, f, u)","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"Em seguida, plotamos o erro HxE junto com um gráfico HxH² para verificarmos o paralelismo e confirmarmos que o erro possui grau 2. Para isso, o plot é feito na escala logarítimica de forma que linearize o grau das curvas.","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"plot(H, E, xaxis = :log10, yaxis = :log10)\nplot!(H, H .^ monta_base(baseType, 2).nB, xaxis = :log10, yaxis = :log10)","category":"page"},{"location":"tutoriais/convergencia/","page":"Estudo de Convergência do Erro","title":"Estudo de Convergência do Erro","text":"(Image: Estudo da Convergência do Erro - Poisson - Gráfico)","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Implementação-Base","page":"Implementação Base","title":"Implementação Base","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Aqui esclareceremos como foi pensada a implementação base deste projeto.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Generalização","page":"Implementação Base","title":"Generalização","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Estruturas","page":"Implementação Base","title":"Estruturas","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"No código existem estruturas e tipos que são essenciais para seu funcionamento e entendimento.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Mesh","page":"Implementação Base","title":"Mesh","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Aqui se encontram valores que definem uma malha. Nela se encontram, por exemplo, o número de subdivisões para cada eixo, número de elementos totais, as coordenadas de cada um dos nós, sua dimensão, a matriz LG, o vetor EQ, entre outros.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Existem funções para montagens específicas de malha. Um exemplo é a assemble_uniform_mesh_1D que retorna uma variável do tipo Mesh para um intervalo uniforme discreto dentro de a b ab.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Manter todos esses valores agrupados, torna-os facilmente acessíveis.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#RunValues","page":"Implementação Base","title":"RunValues","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Essa estrutura é utilizada para agrupar valores normalmente utilizados nos problemas, ou seja, parâmetros, coeficientes, a f e a solução u esperada. É o que retorna quando se chama funções \"exemplos\", localizadas em examples.jl. Seu uso é opcional, recomendado para montar esses exemplos prontos.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#EquationTerms","page":"Implementação Base","title":"EquationTerms","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Para determinar os termos a serem utilizados no operador bilinear a(uv), é necessário o EquationTerms. É uma forma de indicar como u, v, nabla u, nabla v... são aplicados em a(u v).","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Montando-operador-a(u,-v)-e-aplicando-o-na-montagem-do-sistema-linear","page":"Implementação Base","title":"Montando operador a(u v) e aplicando-o na montagem do sistema linear","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"O operador pode se encontrar, por exemplo, na seguinte forma:","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"a(u v) = beta int u(x)cdot v(x)dOmega  + alpha int nablau(x)cdot nablav(x) dOmega","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"No entanto, o que utilizamos é uma forma sem a integração, ou seja, um pseudo operador, por exemplo, pseudo_a(u,v) = β * dot(u, v) + α * dot(∇u, ∇v). Nesse caso, α e β são constantes escolhidas arbitrariamente, mas u, v, ∇u e ∇v são referenciadas diretamente de EquationTerms.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Então, a função que utilizamos para definir esse pseudo operador, na verdade, é:","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"function pseudo_a(equation_terms::EquationTerms)\n  (; ∇u, ∇v, u, v) = equation_terms\n\n  return β * dot(u, v) + α * dot(∇u, ∇v)\nend","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"O argumento equation_terms contém todos os termos possíveis de serem utilizados e pegamos apenas os que queremos em (; ∇u, ∇v, u, v) = equation_terms. Essa nomenclatura (; var1, var2, var3,...) no lado esquerdo da atribuição permite extrair os campos de EquationTerms através de seus nomes, sem precisar de uma ordem específica. Se quisermos um outro, por exemplo, x, podemos digitar (; ∇u, ∇v, u, x, v) = equation_terms.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Já o retorno da função é o que será aplicado na montagem das K locais do problema aproximado. Temos que uma entrada da matriz K^e local é","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"K^e_ab = int alpha nablavarphi^e_b(x(xi)) cdot nablavarphi^e_a(x(xi)) + beta varphi^e_b(x(xi)) cdot varphi^e_a(x(xi)) J(xi)dxi_1dxi_2","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Essa integração é feita com a Quadratura Gaussiana, assim, para cada ponto de gauss i, temos a expressão","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"w_i(alpha nablavarphi^e_b(x(xi)) cdot nablavarphi^e_a(x(xi)) + beta varphi^e_b(x(xi)) cdot varphi^e_a(x(xi)))J(xi)","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Portanto, se substituirmos nablavarphi^e_b(x(xi)) por ∇u, nablavarphi^e_a(x(xi)) por ∇v, varphi^e_b(x(xi)) por u e varphi^e_b(x(xi)) por v, temos wᵢ*(α*∇u⋅∇v + β*u⋅v)|J(ξ)|. Ou seja, a expressão entre parênteses é examente o que a função pseudo_a retorna.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Isso na montagem da K local é feito com o trecho de código a seguir","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"  equation_terms = EquationTerms(\n    ϕᵉ_b,\n    ϕᵉ_a,\n    ∇ϕᵉ_b,\n    ∇ϕᵉ_a\n  )\n  sum = pseudo_a(equation_terms)\n  \"sum = β * dot(ϕᵉ_b, ϕᵉ_a) + α * dot(∇ϕᵉ_b, ∇ϕᵉ_a)\"\n\n  Kᵉ[a, b] += wᵢ * sum * detJ","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Assim, é possível definir uma referência ao operador a(u v), com os termos apresentados, sem precisar mexer no código da montagem da K local.","category":"page"},{"location":"desenvolvimento-colaborativo/implementacao-base/#Adicionando-um-novo-termo","page":"Implementação Base","title":"Adicionando um novo termo","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/implementacao-base/","page":"Implementação Base","title":"Implementação Base","text":"Adicionar um novo termo vem da ideia de tornar flexível a implementação de novos problemas. Necessariamente tem que ser calculado e obtido dentro da montagem da K local, assim como ∇ϕᵉ_b, por exemplo. Um exemplo pronto de como incluir um termo novo se encontra no tutorial","category":"page"},{"location":"reference/#Referências","page":"Referencias","title":"Referências","text":"","category":"section"},{"location":"reference/#Conteúdo","page":"Referencias","title":"Conteúdo","text":"","category":"section"},{"location":"reference/","page":"Referencias","title":"Referencias","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Índice","page":"Referencias","title":"Índice","text":"","category":"section"},{"location":"reference/","page":"Referencias","title":"Referencias","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Fease.Malha","page":"Referencias","title":"Fease.Malha","text":"struct Mesh\n\nValores que definem uma malha.\n\nCampos\n\nbase::Base: Informações sobre o tipo da base de funções interpoladoras\nne::Int64: Número de elementos totais\nneq::Int64: Número de equações\ncoords::Tuple: N-upla com as coordenadas (X₁, X₂, Xᵢ...) dos nós da malha\ndx::: n-upla contendo o intervalo entre os nós, para cada eixo (se uniforme)\nEQ::Vector{Int64}: Vetor com as reenumerações das funções globais ϕ\nLG::Matrix{Int64}: Matriz de conectividade local/global (LG). Relaciona a numeração local e global das funções ϕ\nEQoLG::Matrix{Int64}: Matriz composta entre a EQ e a LG\na::Tuple: Coordenada do início do intervalo\nb::Tuple: Coordenada do final do intervalo\nn_dim::Int64: Número de dimensões da malha\nNx::Tuple: Número de subdivisões da malha para cada eixo\n\n\n\n\n\n","category":"type"},{"location":"reference/#Fease.RunValues","page":"Referencias","title":"Fease.RunValues","text":"struct RunValues\n\nValores que definem parâmetros de um problema.\n\nCampos\n\nα::Float64: Coeficiente α\nβ::Float64: Coeficiente β\nγ::Float64: Coeficiente γ\nf::Function: Função que represnenta o lado direito da equação do problema.\nu::Function: Função que representa a solução analítica da equação do problema.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Fease.TermosEquacao","page":"Referencias","title":"Fease.TermosEquacao","text":"struct EquationTerms\n\nReferências a termos da equação.\n\nCampos\n\nu::: Representa um dos pares do operador linear a(u,v).\nv::: Representa um dos pares do operador linear a(u,v).\n∇u::: Representa o gradiente de um dos pares do operador linear a(u,v).\n∇v::: Representa o gradiente de um dos pares do operador linear a(u,v).\nx::: Termo que permite representar um termo qualquer da equação que dependa de valores no domínio.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Fease.convergence_test!-NTuple{7, Any}","page":"Referencias","title":"Fease.convergence_test!","text":"convergence_test!(E, NE, n_dims, monta_malha, pseudo_a, f, u)\n\nRealiza o estudo da convergência do erro para a solução aproximada da equação com solução exata u.\n\nParâmetros\n\nE::Vetor{Float64}: O vetor onde serão inseridos os erros caculados para cada um das quantidades de elementos finitos.\nNE::Vetor{Float64}: O vetor que contém as cada uma das quantidades de elementos finitos.\nn_dim::Int: Número de dimensões do espaço.\nmonta_malha::Function: Uma função que recebe os números de sub-intervalos da malha e a retorna montada.\npseudo_a: A referência ao operador bilinear a(u,v).\nf::Function: Função que representa o lado direito da equação do problema.\nu::Function: A solução analítica da equação.\n\nRetorno\n\nAltera o vetor E.\n\nExemplo\n\n  # Define o tipo da base de funções interpoladoras do subespaço aproximado Vₘ.\n  baseType = BaseTypes.linearLagrange\n\n  # Define extremos do intervalo da malha.\n  a = (0.0, 0.0)\n  b = (1.0, 1.0)\n\n  # Define os parâmetros da equação a ser resolvida.\n  α = 1.0\n  β = 1.0\n  f = (x₁, x₂) -> (2 * α * π^2 + β) * sin(π * x₁) * sin(π * x₂)\n  u = (x₁, x₂) -> sin(π * x₁) * sin(π * x₂)\n\n  # Define o pseudo operador linear a(u,v).\n  function pseudo_a(termos_equacao)\n    (; ∇u, ∇v, u, v) = termos_equacao\n\n    return β * dot(u, v) + α * dot(∇u, ∇v)\n  end\n\n  # Define a função que constrói uma malha que depende só do número de sub-intervalos nos dois eixos.\n  function monta_malha(NX)\n    return monta_malha_2D_uniforme(baseType, NX..., a, b)\n  end\n\n  # Estudo será realizado com número de elementos em potências de 2.\n  errsize = 7\n  NE = 2 .^ [2:1:errsize;]\n  H = 1 ./ NE\n  E = zeros(length(NE))\n\n  # Calcula o erro para cada uma das quantidades de elementos finitos.\n  convergence_test!(E, NE, 2, monta_malha, pseudo_a, f, u)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.elem_coords-Tuple{Malha, Int64}","page":"Referencias","title":"Fease.elem_coords","text":"elem_coords(malha::Malha, e::Int)\n\nEncontra as coordenadas dos nós do elemento finito e e os retorna, junto a EQoLG referente.\n\nParâmetros\n\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\ne::Int: O identificador numérico do elemento finito Ωᵉ.\n\nRetorno\n\neqs_idx::: EQoLG para o elemento e passado como parâmetro\nXᵉ::Vector: Coordenadas dos vértices do elemento finito Ωᵉ. Cada entrada do vetor representa um eixo.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.jacobiano-NTuple{4, Any}","page":"Referencias","title":"Fease.jacobiano","text":"jacobian(n_dim::Int, Xᵉ::Vector, ∇Φξ::Tuple{Matrix{Float64}}, ξ::Int)\n\nCalcula a matriz jacobiana, assim como seu determinante,  no domínio do elemento determinado pelas coordenadas em Xᵉ.\n\nParâmetros\n\nn_dim::Int: Número de dimensões do espaço.\nXᵉ::Vector: Coordenadas dos vértices do elemento finito Ωᵉ. Cada entrada do vetor representa um eixo.\n∇Φξ::Tuple{Matrix{Float64}}: N-upla de matrizes npg x n_funcs com a avaliaçao das ∂ϕ nos pontos de Gauss-Legendre.\nξ::Int: Representa o número do ponto de Gauss.\n\nRetorno\n\nM::Matrix{Float64}: Matriz jacobiana.\ndetJ::Float64: O determinante da matriz jacobiana\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.malha2D_adiciona_ruido-Tuple{Malha}","page":"Referencias","title":"Fease.malha2D_adiciona_ruido","text":"monta_malha_2D_uniforme(baseType, Nx1, Nx2, a::Tuple, b::Tuple)::Malha\n\nFunção que constrói uma malha 2D uniforme.\n\nParâmetros\n\nbaseType::: O tipo da base das funções interpoladoras.\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64: Número de subdivisões da malha no segundo eixo. \na::Tuple: Coordenada do início do intervalo\nb::Tuple: Coordenada do final do intervalo \n\nRetorno\n\nmalha::Malha: Uma malha 2D uniforme dentro do intervalo [a,b].\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.montaEQ_geral","page":"Referencias","title":"Fease.montaEQ_geral","text":"montaEQ_geral(Nx1::Int64, Nx2::Int64 = 0)\n\nFunção que monta o vetor com as reenumerações das funções globais ϕ.\n\nParâmetros\n\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64 = 0: Número de subdivisões da malha no segundo eixo.\n\nRetorno\n\nEQ::Vector{Int64}: Vetor com as reenumerações das funções globais ϕ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Fease.montaF_geral-Tuple{Function, Malha}","page":"Referencias","title":"Fease.montaF_geral","text":"montaF_geral(f::Function, malha::Malha)\n\nMonta o vetor F global do sistema linear do problema.\n\nParâmetros\n\nf::function: Função que representa o lado direito da equação do problema.\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\n\nRetorno\n\nF::Vector{Float64}: O vetor F global do sistema linear do problema.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.montaFᵉ_geral!-NTuple{8, Any}","page":"Referencias","title":"Fease.montaFᵉ_geral!","text":"montaFᵉ_geral!(Fᵉ, f, Xᵉ, P, W, ϕξ, ∇ϕξ, n_dim)\n\nMonta o vetor local Fᵉ referente à contribuição do elemento e.\n\nParâmetros\n\nFᵉ::Vector{Float64}: Vetor local Fᵉ referente à contribuição do elemento e.\nf::function: Funçãp que represnenta o lado direito da equação do problema.\nXᵉ::Vector: Coordenadas dos vértices do elemento finito Ωᵉ. Cada entrada do vetor representa um eixo.\nP::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um ponto de Gauss-Legendre dimensionado por n_dim.\nW::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um conjunto ordenado de pesos de Gauss-Legendre associados a cada um dos pontos em P.\nϕξ::Matrix{Float64}: Matriz npg x n_funcs com a avaliaçao das ϕ nos pontos de Gauss-Legendre.\n∇ϕξ::Tuple{Matrix{Float64}}: N-upla de matrizes npg x n_funcs com a avaliaçao das ∂ϕ nos pontos de Gauss-Legendre.\nn_dim::Int: Número de dimensões do espaço.\n\nRetorno\n\nAltera Fᵉ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.montaK_geral-Tuple{Malha, Any}","page":"Referencias","title":"Fease.montaK_geral","text":"montaK_geral(malha::Malha, pseudo_a)\n\nMonta a matriz K global do sistema linear do problema.\n\nParâmetros\n\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\npseudo_a::: A referência ao operador bilinear a(u,v).\n\nRetorno\n\nK::Matrix{Float64}: A matriz K global do sistema linear do problema.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.montaKᵉ_geral!-NTuple{8, Any}","page":"Referencias","title":"Fease.montaKᵉ_geral!","text":"montaKᵉ_geral!(Kᵉ, Xᵉ, P, W, Φξ, ∇Φξ, n_dim, pseudo_a)\n\nMonta a matriz local Kᵉ referente à contribuição do elemento e.\n\nParâmetros\n\nKᵉ::Matrix{Float64}: Matriz local Kᵉ referente à contribuição do elemento e.\nXᵉ::Vector: Coordenadas dos vértices do elemento finito Ωᵉ. Cada entrada do vetor representa um eixo.\nP::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um ponto de Gauss-Legendre dimensionado por n_dim.\nW::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um conjunto ordenado de pesos de Gauss-Legendre associados a cada um dos pontos em P.\nΦξ::Matrix{Float64}: Matriz npg x n_funcs com a avaliaçao das ϕ nos pontos de Gauss-Legendre.\n∇Φξ::Tuple{Matrix{Float64}}: N-upla de matrizes npg x n_funcs com a avaliaçao das ∂ϕ nos pontos de Gauss-Legendre.\nn_dim::Int: Número de dimensões do espaço.\npseudo_a: A referência ao operador bilinear a(u,v).\n\nRetorno\n\nAltera Kᵉ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.montaLG_geral","page":"Referencias","title":"Fease.montaLG_geral","text":"montaLG_geral(Nx1::Int64, Nx2::Int64 = 0)\n\nFunção que monta a matriz de conectividade local/global (LG). Relaciona a numeração local e global das funções ϕ.\n\nParâmetros\n\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64 = 0: Número de subdivisões da malha no segundo eixo.\n\nRetorno\n\nLG::Matrix{Int64}: Matriz de conectividade local/global (LG). Relaciona a numeração local e global das funções ϕ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Fease.monta_LG_2D-Tuple{Int64, Int64}","page":"Referencias","title":"Fease.monta_LG_2D","text":"monta_LG_2D(Nx1::Int64, Nx2::Int64)::Matrix{Int64}\n\nFunção que monta a matriz de conectividade local/global (LG). Relaciona a numeração local e global das funções ϕ.\n\nParâmetros\n\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64: Número de subdivisões da malha no segundo eixo.\n\nRetorno\n\nLG::Matrix{Int64}: Matriz de conectividade local/global (LG). Relaciona a numeração local e global das funções ϕ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.monta_malha_1D_uniforme-NTuple{4, Any}","page":"Referencias","title":"Fease.monta_malha_1D_uniforme","text":"monta_malha_1D_uniforme(baseType, Nx1, a, b)::Malha\n\nFunção que constrói uma malha 1D uniforme.\n\nParâmetros\n\nbaseType::: O tipo da base das funções interpoladoras.\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\na::Tuple: Coordenada do início do intervalo uniforme.\nb::Tuple: Coordenada do final do intervalo uniforme.\n\nRetorno\n\nmalha::Malha: Uma malha 1D uniforme dentro do intervalo [a,b].\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.monta_malha_2D_foco","page":"Referencias","title":"Fease.monta_malha_2D_foco","text":"monta_malha_2D_foco(\nbaseType, Nx1, Nx2, a::Tuple, b::Tuple, ponto_foco::Tuple, precisao::Int64)::Malha\n\nFunção que constrói uma malha 2D que cria mais elementos próximos a um ponto especificado.\n\nParâmetros\n\nbaseType::: O tipo da base das funções interpoladoras.\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64: Número de subdivisões da malha no segundo eixo. \na::Tuple: Coordenada do início do intervalo\nb::Tuple: Coordenada do final do intervalo \nponto_foco::Tuple: O ponto na malha onde elementos serão adicionados em volta.\nprecisao::Int64 = 1: A quantidade de iterações de incremento de intervalos em torno do ponto_foco\n\nRetorno\n\nmalha::Malha: Uma malha 2D com concentração de elementos em ponto_foco.\n\nExemplo\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Fease.monta_malha_2D_uniforme-Tuple{Any, Any, Any, Tuple, Tuple}","page":"Referencias","title":"Fease.monta_malha_2D_uniforme","text":"monta_malha_2D_uniforme(baseType, Nx1, Nx2, a::Tuple, b::Tuple)::Malha\n\nFunção que constrói uma malha 2D uniforme.\n\nParâmetros\n\nbaseType::: O tipo da base das funções interpoladoras.\nNx1::Int64: Número de subdivisões da malha no primeiro eixo.\nNx2::Int64: Número de subdivisões da malha no segundo eixo. \na::Tuple: Coordenada do início do intervalo\nb::Tuple: Coordenada do final do intervalo \n\nRetorno\n\nmalha::Malha: Uma malha 2D uniforme dentro do intervalo [a,b].\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.monta_u_aproximada-Tuple{Any, Malha}","page":"Referencias","title":"Fease.monta_u_aproximada","text":"monta_u_aproximada(c::Vector{Float64}, malha::Malha)\n\nDada a solução obtida através do sistema linear e a malha sob a qual foi solucionada, retorna uma função que aproxima a solução analítica do problema.\n\nParâmetros\n\nc::Vector{Float64}: O vetor contendo a solução do sistema linear.\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\n\nRetorno\n\nuh::function: Uma função que aproxima a solução analítica do problema.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.mudanca_variavel_xξ-Tuple{Any, Any, Any}","page":"Referencias","title":"Fease.mudanca_variavel_xξ","text":"mudanca_variavel_xξ(Xᵉ::Vector, Φξ::Vector, n_dim::Int)\n\nMapeia as coordenadas físicas x = (x₁, x₂, xᵢ...) a partir de ξ = (ξ₁, ξ₂, ξᵢ...)\n\nParâmetros\n\nXᵉ::Vector: Coordenadas dos vértices do elemento finito Ωᵉ. Cada entrada do vetor representa um eixo.\nΦξ::Vector: Vetor com o valor das funções locais Φ avaliadas no ponto de Gauss ξ = (ξ₁, ξ₂, ξᵢ...).\nn_dim::Int: Número de dimensões do espaço.\n\nRetorno\n\nx::Vector: A coordenada física referente ao ponto de Gauss ξ.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.plot_malha_2D-Tuple{Malha}","page":"Referencias","title":"Fease.plot_malha_2D","text":"plot_malha_2D(malha::Malha)\n\nPlota o gráfico que representa a malha.\n\nParâmetros\n\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\n\nRetorno\n\nDá display no gráfico plotado.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.plot_solucao_aproximada","page":"Referencias","title":"Fease.plot_solucao_aproximada","text":"plot_solucao_aproximada(c::Array, malha::Malha, gif::Bool = false)\n\nA partir da solução do sistema e a malha, plota a solução aproximada.  No caso do espaço ser bidimensional é possível atribuir gif = true para que o plot seja um gif animado com visão 360⁰.\n\nParâmetros\n\nc::Array: O vetor contendo a solução do sistema linear.\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\ngif::Bool = false: Flag para plotar o gráfico como um gif animado.\n\nRetorno\n\nNão há retorno, porém dá display no gráfico plotado.\n\nExemplo\n\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Fease.quadratura_gauss-Tuple{Int64, Int64}","page":"Referencias","title":"Fease.quadratura_gauss","text":"quadratura_gauss(npg::Int, n_dim::Int)\n\nDefine os npg pontos de Gauss-Legendre P e os pesos associados W.  Cada um dos pontos em P são n-uplas dimensionadas por n_dim. Os pesos associados W funcionam analogamente.\n\nParâmetros\n\nnpg::Int: Número de pontos de integração de Gauss-Legendre.\nn_dim::Int: Número de dimensões do espaço. Tamanho dos pontos de Gauss-Legendre.\n\nRetorno\n\nP::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um ponto de Gauss-Legendre dimensionado por n_dim.\nW::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um conjunto ordenado de pesos de Gauss-Legendre associados a cada um dos pontos em P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.quadratura_ϕ-Tuple{Any, Int64, Int64}","page":"Referencias","title":"Fease.quadratura_ϕ","text":"quadratura_ϕ(base, npg::Int, n_dim::Int)\n\nAvalia cada uma das funções ϕ em cada um dos npg pontos de Gauss-Legendre e armazena o resultado em uma matriz ϕP: npg x n_funcs.\n\nParâmetros\n\nn_funcs::Int: Número de funções base.\nnpg::Int: Número de pontos de integração de Gauss-Legendre.\nn_dim::Int: Número de dimensões do espaço. Tamanho dos pontos de Gauss-Legendre.\n\nRetorno\n\nϕP::Matrix{Float64}: Matriz npg x n_funcs com a avaliaçao das ϕ nos pontos de Gauss-Legendre.\nP::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um ponto de Gauss-Legendre dimensionado por n_dim.\nW::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um conjunto ordenado de pesos de Gauss-Legendre associados a cada um dos pontos em P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.quadratura_∇ϕ-Tuple{Any, Int64, Int64}","page":"Referencias","title":"Fease.quadratura_∇ϕ","text":"quadratura_∇ϕ(base, npg::Int, n_dim::Int)\n\nAvalia cada uma das funções ∂ϕ, para cada uma das n_dim dimensões, em cada um dos npg pontos de Gauss-Legendre e  armazena o resultado em uma n-upla ∇ϕP de matrizes ∂ϕP: npg x n_funcs.\n\nParâmetros\n\nn_funcs::Int: Número de funções base.\nnpg::Int: Número de pontos de integração de Gauss-Legendre.\nn_dim::Int: Número de dimensões do espaço. Tamanho dos pontos de Gauss-Legendre.\n\nRetorno\n\n∇ϕP::Tuple{Matrix{Float64}}: N-upla de matrizes npg x n_funcs com a avaliaçao das ∂ϕ nos pontos de Gauss-Legendre.\nP::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um ponto de Gauss-Legendre dimensionado por n_dim.\nW::Vector{Tuple}: Vetor de n-uplas, onde cada n-upla é um conjunto ordenado de pesos de Gauss-Legendre associados a cada um dos pontos em P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.solve_sys-Tuple{Any, Any, Any}","page":"Referencias","title":"Fease.solve_sys","text":"solve_sys(f::function, malha::Malha, pseudo_a::function)\n\nMonta e soluciona o sistema linear KC = F,  considerando a referência ao operador bilinear a(u,v) obtido na formulação fraca.\n\nParâmetros\n\nrun_values::RunValues: Estrutura que contém parâmetros do problema.\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\n\nRetorno\n\nC::Vector{Float64}: O vetor contendo a solução do sistema linear.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.solve_sys_poisson-Tuple{RunValues, Malha}","page":"Referencias","title":"Fease.solve_sys_poisson","text":"solve_sys_poisson(run_values::RunValues, malha::Malha)\n\nMonta e soluciona o sistema linear KC = F, considerando o problema com equação de Poisson.\n\nParâmetros\n\nrun_values::RunValues: Estrutura que contém parâmetros do problema.\nmalha::Malha: A malha sob a qual está sendo solucionado o problema.\n\nRetorno\n\nC::Vector{Float64}: O vetor contendo a solução do sistema linear.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.ϕ_1D-Tuple","page":"Referencias","title":"Fease.ϕ_1D","text":"ϕ_1D(P...)\n\nCalcula os valores das funções interpoladoras ϕ no ponto P, unidimensional.\n\nParâmetros\n\nP...: Ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\nϕ::Vector{Float64}: Vetor com os valores das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.ϕ_2D-Tuple{Float64, Float64}","page":"Referencias","title":"Fease.ϕ_2D","text":"ϕ_2D(ξ₁::Float64, ξ₂::Float64)::Vector{Float64}\n\nCalcula os valores das funções interpoladoras ϕ no ponto P, unidimensional.\n\nParâmetros\n\nξ₁::Float64: Valor no primeiro eixo do ponto onde as funções interpoladoras serão calculadas.\nξ₂::Float64: Valor no segundo eixo do ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\nϕ::Vector{Float64}: Vetor com os valores das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.ϕ_geral-Tuple","page":"Referencias","title":"Fease.ϕ_geral","text":"ϕ_geral(P...)\n\nCalcula os valores das funções interpoladoras ϕ no ponto P.\n\nParâmetros\n\nP...: Ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\nϕ::Vector{Float64}: Vetor com os valores das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.∂ϕ_∂ξ₁-Tuple{Float64}","page":"Referencias","title":"Fease.∂ϕ_∂ξ₁","text":"∂ϕ_∂ξ₁(ξ₂::Float64)::Vector{Float64}\n\nDefinição das ∂ϕ_∂ξ₁ lagrange linear para o caso 2D\n\nParâmetros\n\nξ₂::Float64: Valor no segundo eixo do ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\n∂ϕ_∂ξ₁::Vector{Float64}: Vetor com os valores das derivadas das funções interpoladoras ϕ no ponto P, no primeiro eixo.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.∂ϕ_∂ξ₂-Tuple{Float64}","page":"Referencias","title":"Fease.∂ϕ_∂ξ₂","text":"∂ϕ_∂ξ₂(ξ₁::Float64)::Vector{Float64}\n\nDefinição das ∂ϕ_∂ξ₂ lagrange linear para o caso 2D\n\nParâmetros\n\nξ₁::Float64: Valor no primeiro eixo do ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\n∂ϕ_∂ξ₂::Vector{Float64}: Vetor com os valores das derivadas das funções interpoladoras ϕ no ponto P, no segundo eixo.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.∇ϕ_1D-Tuple","page":"Referencias","title":"Fease.∇ϕ_1D","text":"∇ϕ_1D(P...)\n\nCalcula os valores das derivadas das funções interpoladoras ϕ no ponto P.\n\nParâmetros\n\nP...: Ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\n∇ϕ::Vector{Float64}: Vetor com os valores das derivadas das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.∇ϕ_2D-Tuple{Float64, Float64}","page":"Referencias","title":"Fease.∇ϕ_2D","text":"∇ϕ_2D(ξ₁::Float64, ξ₂::Float64)\n\nCalcula os valores do gradiente das funções interpoladoras ϕ no ponto P.\n\nParâmetros\n\nξ₁::Float64: Valor no primeiro eixo do ponto onde as funções interpoladoras serão calculadas.\nξ₂::Float64: Valor no segundo eixo do ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\n∇ϕ::Tuple: Tupla com os valores do gradiente das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#Fease.∇ϕ_geral-Tuple","page":"Referencias","title":"Fease.∇ϕ_geral","text":"∇ϕ_geral(P...)\n\nCalcula os valores do gradiente das funções interpoladoras ϕ no ponto P.\n\nParâmetros\n\nP...: Ponto onde as funções interpoladoras serão calculadas.\n\nRetorno\n\n∇ϕ::Tuple: Tupla com os valores do gradiente das funções interpoladoras ϕ no ponto P.\n\nExemplo\n\n\n\n\n\n\n\n","category":"method"},{"location":"para-comecar/para-começar-a-desenvolver/#Para-começar-a-desenvolver","page":"A Desenvolver","title":"Para começar a desenvolver","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Neste capítulo esclareceremos os passos necessários para começar a desenvolver e contribuir com o pacote.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/#Clonando-o-projeto","page":"A Desenvolver","title":"Clonando o projeto","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Em um terminal com o diretório de trabalho em uma pasta de sua escolha, execute os comandos abaixo (Windows ou Linux)","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"git clone https://github.com/Mesquitaaph/Fease.jl.git\ncd Fease","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Em seguida, você pode abrir o projeto com o VSCode com mais um comando","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"code .","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/#Durante-o-desenvolvimento...-(Essa-parte-talvez-entre-nas-diretrizes-de-dev-colab)","page":"A Desenvolver","title":"Durante o desenvolvimento... (Essa parte talvez entre nas diretrizes de dev colab)","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Acredito que a melhor forma de testar uma nova implementação seria incluindo um novo arquivo com exemplo de como utilizá-la, na pasta exemplos, na raíz do projeto. Inicialmente existem dois arquivos: caso1D.jl e caso2D.jl, cada um com um exemplo distinto.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/#Desenvolvendo-com-VSCode","page":"A Desenvolver","title":"Desenvolvendo com VSCode","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Recomendamos que seja instalada a extensão de Julia em sua instalação do VSCode. Com o auxílio deste passo a passo , pesquise por julialang.language-julia e clique em \"instalar\".","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Agora você deve iniciar o REPL de Julia. Com um arquivo .jl do projeto, pode fazer isso apertando as teclas Ctrl+Shift+P e digitar Start REPL.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Ao iniciar o REPL da Julia, você verá escrito julia> no terminal integrado do VSCode. Para testar o Fease.jl digite ] na linha de comando para entrar no modo package. Deverá aparecer (Fease) pkg> no lugar. Para verificar se o pacote está funcionando corretamente execute o comando test como apresentado abaixo.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"(Fease) pkg> test Fease\n  Testing Fease\n  Status ...","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Ao final deverá aparecer algo como","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"    Testing Running tests...\nTest Summary: | Pass  Total  Time\ncaso1D.jl     |    2      2  0.6s\nTest Summary: | Pass  Total  Time\ncaso2D.jl     |    2      2  0.1s\n    Testing Fease tests passed","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/#Instalando-e-configurando-o-Revise.jl","page":"A Desenvolver","title":"Instalando e configurando o Revise.jl","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"O Revise.jl é um pacote a ser instalado globamente que auxilia no desenvolvimento de pacotes Julia. Ele atualiza o pacote local automaticamente ao salvar o arquivo. Isso reduz a quantidadade de vezes que precisamos reiniciar o ambiente/REPL.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Ainda com o terminal integrado do VSCode aberto, entre no modo package e digite activate:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"(Fease) pkg> activate","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Deverá mudar de (Fease) pkg> para (@v1.11) pkg> (ou para a versão de Julia que estiver instalada em sua máquina). Com isso, prossiga:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"(@v1.11) pkg> add Revise","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Adicionando-o com sucesso, o Revise.jl estará instalado globalmente.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Para configurá-lo, abra um outro terminal do seu sistema operacional e execute:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Terminal do Linux","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"mkdir -p ~/.julia/config/ && echo \"using Revise\" >> ~/.julia/config/startup.jl","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Cmd do Windows","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"mkdir %userprofile%\\.julia\\config && echo using Revise >> %userprofile%\\.julia\\config\\startup.jl","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Agora reabra o VSCode e inicie o REPL. Execute:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"julia> using Fease","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/#Testando-mudanças-no-pacote","page":"A Desenvolver","title":"Testando mudanças no pacote","text":"","category":"section"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Na raíz do projeto, dentro da pasta src/testes, crie um arquivo Julia, por exemplo teste.jl e inclua-o no arquivo include_testes.jl digitando, ao final do arquivo:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"include(\"teste.jl\")","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"De volta ao arquivo criado, digite:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"test_revise()","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Para executar essa função clique no botão de play no canto superior direito da janela do VSCode para executar o arquivo inteiro ou clicando na linha com o trecho do código e apertando no teclado Ctrl+Enter. O resultado será apresentado no terminal, rodando a função com a primeira opção, ou na linha, com a segunda opção. Deverá aparecer true.","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Agora segure a tecla Ctrl e clique na função test_revise. Este atalho abrirá o arquivo utils.jl, onde encontra sua definição, na linha certa. Troque seu retorno de true para false:","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"function test_revise()\n  return false\nend","category":"page"},{"location":"para-comecar/para-começar-a-desenvolver/","page":"A Desenvolver","title":"A Desenvolver","text":"Volte ao arquivo teste.jl e execute novamente a função. Se desta vez aparecer false, o Revise está funcionando e, assim, seu ambiente estará configurado e pronto para você desenvolver!","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Diretrizes-para-o-Desenvolvimento-Colaborativo","page":"Diretrizes de Desenvolvimento","title":"Diretrizes para o Desenvolvimento Colaborativo","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Aqui apresentaremos o que deve ser seguido durante a implementação de novas funcionalidades, melhorias ou correções com o objetivo de manter o projeto sustentável e escalável, englobando desenvolvedores com experiências de programação em diferentes níveis.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Durante-o-desenvolvimento...","page":"Diretrizes de Desenvolvimento","title":"Durante o desenvolvimento...","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"A melhor forma de testar uma nova implementação é incluindo um novo arquivo na pasta src/testes, como apresentado em Para Começar a Desenvolver.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Uma vez finalizada, se sua implementação incluir algo novo, que seja necessário um tutorial, como por exemplo, um problema que não existe, deve-se incluir um exemplo base na pasta example na raíz do projeto. Inicialmente existem dois arquivos: caso1D.jl e caso2D.jl, cada um com um exemplo distinto.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Legibilidade","page":"Diretrizes de Desenvolvimento","title":"Legibilidade","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"A legibilidade do código é definida por alguns pontos:","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Idioma-do-código","page":"Diretrizes de Desenvolvimento","title":"Idioma do código","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Apesar da documentação ser escrita em português, nosso código deve ser escrito em inglês.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Práticas-de-Escrita-Convenção-de-Nomenclatura","page":"Diretrizes de Desenvolvimento","title":"Práticas de Escrita - Convenção de Nomenclatura","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Deve-se utilizar snake_case para nome de funções e variáveis, por exemplo, test_revise e CamelCase para tipos implementados e arquivos, por exemplo, EquationTerms.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Nomes-de-funções,-variáveis,-tipos-e-nomes-de-arquivo","page":"Diretrizes de Desenvolvimento","title":"Nomes de funções, variáveis, tipos e nomes de arquivo","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Funções e variáveis devem ser nomeadas de forma clara e descritiva, facilitando a leitura e compreensão de quem vai trabalhar com sua implementação. Sempre que possível use palavras inteiras. Por exemplo: escrevi uma função que monta e retorna uma malha 2D. Nomearei-a como assemble_mesh_2D.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/#Identação,-espaçamento-e-outras-definições-de-escrita","page":"Diretrizes de Desenvolvimento","title":"Identação, espaçamento e outras definições de escrita","text":"","category":"section"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Essas outras escolhas de estilo de escrita são aplicadas automaticamente pelo formatter configurado no projeto. No VSCode, todos os arquivos são auto-formatados ao salvar, não sendo necessário se preocupar com isso.","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"Caso não esteja utilizando o VSCode, deve-se executar","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"julia> using Fease\njulia> format(\".\")","category":"page"},{"location":"desenvolvimento-colaborativo/diretrizes-desenvolvimento/","page":"Diretrizes de Desenvolvimento","title":"Diretrizes de Desenvolvimento","text":"para formatar todos os arquivos modificados.","category":"page"},{"location":"metodo-elementos-finitos/#Método-de-Elementos-Finitos","page":"Método de Elementos Finitos","title":"Método de Elementos Finitos","text":"","category":"section"},{"location":"metodo-elementos-finitos/","page":"Método de Elementos Finitos","title":"Método de Elementos Finitos","text":"Aqui apresentaremos a Introdução ao Método de Elementos Finitos. Talvez mais.","category":"page"},{"location":"#Fease.jl","page":"Início","title":"Fease.jl","text":"","category":"section"},{"location":"","page":"Início","title":"Início","text":"Documentação do pacote Fease.jl - Finite Element Analysis for Solving Equations.","category":"page"},{"location":"","page":"Início","title":"Início","text":"note: Note\nTodas essas páginas da documentação estão sob construção.","category":"page"},{"location":"#Introdução","page":"Início","title":"Introdução","text":"","category":"section"},{"location":"","page":"Início","title":"Início","text":"O Fease.jl tem como objetivo ser fácil para usar e modificar, independente do nível de experiência do desenvolvedor. O motivo principal da sua existência vem do Laboratório de Computação Científica e Combinatória (LC³), onde, por diversas vezes, estudantes de outros cursos de ciências exatas, que desejam estudar o método de Elementos Finitos, deixaram de se vincular, no mestrado, por não possuírem formação em programação. Portanto, este pacote visa tentar diminuir essa barreira o máximo possível.","category":"page"},{"location":"","page":"Início","title":"Início","text":"Portanto, em seu desenvolvimento, utilizamos muitos símbolos matemáticos e nomenclaturas similares às presentes durantes as aulas de \"Introdução ao Método de Elementos Finitos\", em que estes mestrandos participam.","category":"page"},{"location":"","page":"Início","title":"Início","text":"Além disso, todas as estruturas desenvolvidas e formas de implementar certas funções foram escolhidas pensando no aspecto facilitador do Fease.jl.","category":"page"},{"location":"#Caminho-do-Usuário","page":"Início","title":"Caminho do Usuário","text":"","category":"section"},{"location":"","page":"Início","title":"Início","text":"Seguir o passo-a-passo em Para Começar a Utilizar.","category":"page"},{"location":"","page":"Início","title":"Início","text":"Por enquanto só o passo 1 basta. Abaixo são os possíveis próximos passos.","category":"page"},{"location":"","page":"Início","title":"Início","text":"Ler o Método de Elementos Finitos\nLer um dos Tutoriais.","category":"page"},{"location":"#Caminho-do-Desenvolvedor","page":"Início","title":"Caminho do Desenvolvedor","text":"","category":"section"},{"location":"","page":"Início","title":"Início","text":"Seguir o passo-a-passo em Para Começar a Desenvolver.\nLer o Método de Elementos Finitos.\nLer um dos Tutoriais.\nLer as Diretrizes de Desenvolvimento Colaborativo e a apresentação da Implementação Base.","category":"page"}]
}
